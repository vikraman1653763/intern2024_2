
{% extends 'base.html' %}
    
{% block body %}


<div>
    <div class="row">
        
        <div id="sidebar" >
            <h2>Layers</h2>
            <div class="checkbox-wrapper">
                <input id="Open Street Map" type="checkbox" value="Open Street Map" checked onchange="toggleLayer(event)">
                <label for="Open Street Map"><div class="tick_mark"></div></label>
                <span>Open Map</span>
            </div>
            <br>
            <div class="checkbox-wrapper">
                <input id="satellite"type="checkbox"  value="satellite" checked onchange="toggleLayer(event)">
                <label for="satellite"><div class="tick_mark"></div></label>
                <span>satellite</span>
            </div>
            <BR>
            {% for l in layer_list %}
            <div class="checkbox-wrapper">
                <input id="{{ l }}" type="checkbox" value="{{ l }}" checked onchange="toggleLayer(event)">
                <label for="{{ l }}"><div class="tick_mark"></div></label>
                <span>{{ l }}</span>
            </div>
            <br>
            {% endfor %}
           
        </div>
      



        <div class="col-sm-10" style="padding: 0%;margin: 0%; width:10px;">
            <div id="map"></div>
            
            <div class="btnn">
            
            <button id="toggle-btn" class="myButton bigbtn" > 
                
                <img src="\static\resources\images\layers.svg"  alt="">
            </button>
            <button id="toggleButton" onclick="toggleTooly()" class="myButton bigbtn"><img src="\static\resources\images\edit.svg"  alt="">
            </button>
                <div class="container">
                    <div class="tooly">
                        <button id="homeButton" class="myButton" >
                            <img src="/static/resources/images/homebtn.svg" alt="" ></img>
                        </button>
                        <!-- Zoom Out Button -->
                        <button id="zoButton" class="myButton"  >
                            <img src="/static/resources/images/zoomminus.svg" alt="" ></img>
                        </button>
                        <!-- Zoom In Button -->
                        <button id="ziButton" class="myButton"  >
                            <img src="/static/resources/images/zoomplus.svg" alt="" ></img>
                        </button>
                        <!-- Length Control Button -->
                        <button id="lengthButton" class="myButton"  >
                            <img src="/static/resources/images/scale.svg" alt="" ></img>
                        </button>
                        <!-- Area Control Button -->
                        <button id="areaButton" class="myButton"  >
                            <img src="/static/resources/images/area.svg" alt="" ></img>
                        </button>
                        <!-- Full Screen Button -->
                        <button id="fsButton" class="myButton"  >
                            <img src="/static/resources/images/full.svg" alt="" ></img>
                        </button>
                    </div >
                </div>
        </div>
        </div>

    </div>
</div>

<style>
    
       
    
        .rightcls {
            margin-right: -100px; /* Move the button to the left side */
            transition: margin-right 0.3s ease-in-out; /* Adjust transition property */
        }
        
     


</style>
<div id="popup" class="ol-popup">

    <a href="#" id="popup-closer" class="ol-popup-closer"></a>
    <div id="popup-content"></div>
</div> 
<link rel="stylesheet" href="/static/styles/mapstyle.css">

<script src="/static/resources/ol/ol.js"></script>
<script src="/static/resources/layerswitcher/ol-layerswitcher.js"></script>
<script src="/static/js/MapView.js"></script>
<script src="/static/js/controls.js"></script>
<script  type="text/javascript">

    function toggleTooly() {
        var toolyDiv = document.querySelector('.tooly');
        var togImage = document.querySelector('#toggleButton img');

        if (toolyDiv.classList.contains('show')) {
            toolyDiv.classList.remove('show'); 
            toolyDiv.classList.add('hide');
            togImage.classList.remove('clicked-image-border'); // Remove border from the image
        } else {
            toolyDiv.classList.remove('hide');
            toolyDiv.classList.add('show'); 
            
            togImage.classList.add('clicked-image-border'); // Add border to the image
        }
    };

   
  
    $(document).ready(function() {
        var mybtnDiv = $('.myButton');
        var homeButton = $('#homeButton'); // Select the homeButton element
        
        $("#toggle-btn").click(function() {
            $("#sidebar").toggleClass("sidebar-visible"); 
            
            // Toggle class for myButton elements
            mybtnDiv.each(function() {
                $(this).toggleClass("rightcls");
            });
            
            // Toggle class for the homeButton element
            homeButton.toggleClass("rightcls");
        });   
    });
    
    

        function toggleLayer(eve){

            var lyername = eve.target.value;
            var checkedStatus = eve.target.checked;
            var lyrList = map.getLayers();

            // var lyrList = layer_names;

            console.log("layername ",lyername);
            console.log("checked ", checkedStatus);
            console.log("lyrList ", lyrList);


            lyrList.forEach(function(element) {
                
                // console.log(element.get('title'));
                if(lyername == element.get('title')){

                    // console.log(element.get('title'));

                    element.setVisible(checkedStatus);
                }
                
            });
            
        }

        //mapView             
        var map = mapView(
            JSON.parse('{{ lay | safe }}'),
            JSON.parse('{{ workspace | safe }}'),
            JSON.parse('{{ ngrok_ip | safe }}'),
            JSON.parse('{{ lon | safe }}'),
            JSON.parse('{{ lat | safe }}'),
            JSON.parse('{{ zoom | safe }}')
        );
        var scaleControl  = new ol.control.ScaleLine({
            bar: true,
            text: true
        });

        map.addControl(scaleControl);


        var container = document.getElementById('popup');
        var content = document.getElementById('popup-content');
        var closer = document.getElementById('popup-closer');

        var popup = new ol.Overlay({
            element: container,
            autoPan: true,
            autoPanAnimation: {
                duration: 250,
            },
        });

        map.addOverlay(popup);

        closer.onclick = function () {
            popup.setPosition(undefined);
            closer.blur();
            return false;
        };

        var dashboardUrl = "{{ url_for('dashboard') }}";


        // home Control
        
       
        
        
       
        createControls();
        /**
        * Message to show when the user is drawing a polygon.
        * @type {string}
        */
        var continuePolygonMsg = 'Click to continue polygon, Double click to complete';

        /**
        * Message to show when the user is drawing a line.
        * @type {string}
        */
        var continueLineMsg = 'Click to continue line, Double click to complete';

        var draw; // global so we can remove it later

        var source = new ol.source.Vector();
        var vector = new ol.layer.Vector({
            source: source,
            style: new ol.style.Style({
                fill: new ol.style.Fill({
                    color: 'rgba(255, 255, 255, 0.2)',
                }),
                stroke: new ol.style.Stroke({
                    color: '#ffcc33',
                    width: 2,
                }),
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({
                        color: '#ffcc33',
                    }),
                }),
            }),
        });

        map.addLayer(vector);

        function addInteraction(intType) {

            draw = new ol.interaction.Draw({
                source: source,
                type: intType,
                style: new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: 'rgba(200, 200, 200, 0.6)',
                    }),
                    stroke: new ol.style.Stroke({
                        color: 'rgba(0, 0, 0, 0.5)',
                        lineDash: [10, 10],
                        width: 2,
                    }),
                    image: new ol.style.Circle({
                        radius: 5,
                        stroke: new ol.style.Stroke({
                            color: 'rgba(0, 0, 0, 0.7)',
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0.2)',
                        }),
                    }),
                }),
            });
            map.addInteraction(draw);

            createMeasureTooltip();
            createHelpTooltip();

            /**
            * Currently drawn feature.
            * @type {import("../src/ol/Feature.js").default}
            */
            var sketch;

            /**
            * Handle pointer move.
            * @param {import("../src/ol/MapBrowserEvent").default} evt The event.
            */
            var pointerMoveHandler = function (evt) {
                if (evt.dragging) {
                    return;
                }
                /** @type {string} */
                var helpMsg = 'Click to start drawing';

                if (sketch) {
                    var geom = sketch.getGeometry();
                    // if (geom instanceof ol.geom.Polygon) {
                    //   helpMsg = continuePolygonMsg;
                    // } else if (geom instanceof ol.geom.LineString) {
                    //   helpMsg = continueLineMsg;
                    // }
                }

                //helpTooltipElement.innerHTML = helpMsg;
                //helpTooltip.setPosition(evt.coordinate);

                //helpTooltipElement.classList.remove('hidden');
            };

            map.on('pointermove', pointerMoveHandler);

            // var listener;
            draw.on('drawstart', function (evt) {
                // set sketch
                sketch = evt.feature;

                /** @type {import("../src/ol/coordinate.js").Coordinate|undefined} */
                var tooltipCoord = evt.coordinate;

                //listener = sketch.getGeometry().on('change', function (evt) {
                sketch.getGeometry().on('change', function (evt) {
                    var geom = evt.target;
                    var output;
                    if (geom instanceof ol.geom.Polygon) {
                        output = formatArea(geom);
                        tooltipCoord = geom.getInteriorPoint().getCoordinates();
                    } else if (geom instanceof ol.geom.LineString) {
                        output = formatLength(geom);
                        tooltipCoord = geom.getLastCoordinate();
                    }
                    measureTooltipElement.innerHTML = output;
                    measureTooltip.setPosition(tooltipCoord);
                });
            });

            draw.on('drawend', function () {
                measureTooltipElement.className = 'ol-tooltip ol-tooltip-static';
                measureTooltip.setOffset([0, -7]);
                // unset sketch
                sketch = null;
                // unset tooltip so that a new one can be created
                measureTooltipElement = null;
                createMeasureTooltip();
                //ol.Observable.unByKey(listener);
            });
        }


        /**
        * The help tooltip element.
        * @type {HTMLElement}
        */
        var helpTooltipElement;

        /**
        * Overlay to show the help messages.
        * @type {Overlay}
        */
        var helpTooltip;

        /**
        * Creates a new help tooltip
        */
        function createHelpTooltip() {
            if (helpTooltipElement) {
                helpTooltipElement.parentNode.removeChild(helpTooltipElement);
            }
            helpTooltipElement = document.createElement('div');
            helpTooltipElement.className = 'ol-tooltip hidden';
            helpTooltip = new ol.Overlay({
                element: helpTooltipElement,
                offset: [15, 0],
                positioning: 'center-left',
            });
            map.addOverlay(helpTooltip);
        }

        // map.getViewport().addEventListener('mouseout', function () {
        //     helpTooltipElement.classList.add('hidden');
        // });

        /**
        * The measure tooltip element.
        * @type {HTMLElement}
        */
        var measureTooltipElement;


        /**
        * Overlay to show the measurement.
        * @type {Overlay}
        */
        var measureTooltip;

        /**
        * Creates a new measure tooltip
        */

        function createMeasureTooltip() {
            if (measureTooltipElement) {
                measureTooltipElement.parentNode.removeChild(measureTooltipElement);
            }
            measureTooltipElement = document.createElement('div');
            measureTooltipElement.className = 'ol-tooltip ol-tooltip-measure';
            measureTooltip = new ol.Overlay({
                element: measureTooltipElement,
                offset: [0, -15],
                positioning: 'bottom-center',
            });
            map.addOverlay(measureTooltip);
        }





        /**
        * Format length output.
        * @param {LineString} line The line.
        * @return {string} The formatted length.
        */
        var formatLength = function (line) {
            var length = ol.sphere.getLength(line);
            var output;
            if (length > 100) {
                output = Math.round((length / 1000) * 100) / 100 + ' ' + 'km';
            } else {
                output = Math.round(length * 100) / 100 + ' ' + 'm';
            }
            return output;
        };

        /**
        * Format area output.
        * @param {Polygon} polygon The polygon.
        * @return {string} Formatted area.
        */
        var formatArea = function (polygon) {
            var area = ol.sphere.getArea(polygon);
            var output;
            if (area > 10000) {
                output = Math.round((area / 1000000) * 100) / 100 + ' ' + 'km<sup>2</sup>';
            } else {
                output = Math.round(area * 100) / 100 + ' ' + 'm<sup>2</sup>';
            }
            return output;
        };

       

        function newaddGeoJsonToMap(url) {

            if (geojson) {
                geojson.getSource().clear();
                map.removeLayer(geojson);
            }

            var style = new ol.style.Style({
                // fill: new ol.style.Fill({
                //   color: 'rgba(0, 255, 255, 0.7)'
                // }),
                stroke: new ol.style.Stroke({
                    color: '#FFFF00',
                    width: 3
                }),
                image: new ol.style.Circle({
                    radius: 7,
                    fill: new ol.style.Fill({
                        color: '#FFFF00'
                    })
                })
            });

            geojson = new ol.layer.Vector({
                source: new ol.source.Vector({
                    url: url,
                    format: new ol.format.GeoJSON()
                }),
                style: style,

            });

            geojson.getSource().on('addfeature', function () {
                map.getView().fit(
                    geojson.getSource().getExtent(),
                    { duration: 1590, size: map.getSize(), maxZoom: 21 }
                );
            });
            map.addLayer(geojson);
        };

        function newpopulateQueryTable(url) {
            if (typeof attributePanel !== 'undefined') {
                if (attributePanel.parentElement !== null) {
                    attributePanel.close();
                }
            }
            $.getJSON(url, function (data) {
                var col = [];
                col.push('id');
                for (var i = 0; i < data.features.length; i++) {

                    for (var key in data.features[i].properties) {

                        if (col.indexOf(key) === -1) {
                            col.push(key);
                        }
                    }
                }

                var table = document.createElement("table");

                table.setAttribute("class", "table table-bordered table-hover table-condensed");
                table.setAttribute("id", "attQryTable");
                // CREATE HTML TABLE HEADER ROW USING THE EXTRACTED HEADERS ABOVE.

                var tr = table.insertRow(-1);                   // TABLE ROW.

                for (var i = 0; i < col.length; i++) {
                    var th = document.createElement("th");      // TABLE HEADER.
                    th.innerHTML = col[i];
                    tr.appendChild(th);
                }

                // ADD JSON DATA TO THE TABLE AS ROWS.
                for (var i = 0; i < data.features.length; i++) {
                    tr = table.insertRow(-1);
                    for (var j = 0; j < col.length; j++) {
                        var tabCell = tr.insertCell(-1);
                        if (j == 0) { tabCell.innerHTML = data.features[i]['id']; }
                        else {
                            tabCell.innerHTML = data.features[i].properties[col[j]];
                        }
                    }
                }

                // var tabDiv = document.createElement("div");
                var tabDiv = document.getElementById('attListDiv');

                var delTab = document.getElementById('attQryTable');
                if (delTab) {
                    tabDiv.removeChild(delTab);
                }

                tabDiv.appendChild(table);

                document.getElementById("attListDiv").style.display = "block";
            });

        };

        var highlightStyle = new ol.style.Style({
            fill: new ol.style.Fill({
            color: 'rgba(255,0,255,0.3)',
            }),
            stroke: new ol.style.Stroke({
                color: '#FF00FF',
                width: 3,
            }),
            image: new ol.style.Circle({
                radius: 10,
                fill: new ol.style.Fill({
                    color: '#FF00FF'
                })
            })
        });


        var featureOverlay = new ol.layer.Vector({
            source: new ol.source.Vector(),
            map: map,
            style: highlightStyle
        });

        function newaddRowHandlers() {
            var table = document.getElementById("attQryTable");
            var rows = document.getElementById("attQryTable").rows;
            var heads = table.getElementsByTagName('th');
            var col_no;
            for (var i = 0; i < heads.length; i++) {
                // Take each cell
                var head = heads[i];
                if (head.innerHTML == 'id') {
                    col_no = i + 1;
                }

            }
            for (i = 0; i < rows.length; i++) {
                rows[i].onclick = function () {
                    return function () {
                        featureOverlay.getSource().clear();

                        $(function () {
                            $("#attQryTable td").each(function () {
                                $(this).parent("tr").css("background-color", "white");
                            });
                        });
                        var cell = this.cells[col_no - 1];
                        var id = cell.innerHTML;
                        $(document).ready(function () {
                            $("#attQryTable td:nth-child(" + col_no + ")").each(function () {
                                if ($(this).text() == id) {
                                    $(this).parent("tr").css("background-color", "#d1d8e2");
                                }
                            });
                        });

                        var features = geojson.getSource().getFeatures();

                        for (i = 0; i < features.length; i++) {
                            if (features[i].getId() == id) {
                                featureOverlay.getSource().addFeature(features[i]);

                                featureOverlay.getSource().on('addfeature', function () {
                                    map.getView().fit(
                                        featureOverlay.getSource().getExtent(),
                                        { duration: 1500, size: map.getSize(), maxZoom: 24 }
                                    );
                                });

                            }
                        }
                    };
                }(rows[i]);
            }
        }

        // end : attribute query        
</script>

    
{% endblock %}

